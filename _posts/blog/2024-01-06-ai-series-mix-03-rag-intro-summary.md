---
layout: post
title: AI 系列：LLMs 的 RAG 综述
description: 面向大语言模型的，检索增强生成技术综述
published: true
category: AI
---

> 
> 虽然说的是 RAG 的综述，其实涵盖了非常多的核心概念，值得好好读几遍。
> 
> 原文地址： [Retrieval-Augmented Generation for Large Language Models: A Survey](https://arxiv.org/abs/2312.10997)
> 
> 译文地址： [面向大语言模型的检索增强生成技术：综述](https://baoyu.io/translations/ai-paper/2312.10997-retrieval-augmented-generation-for-large-language-models-a-survey)
> 
> 


在这篇综述中，我们关注的是面向大语言模型（Large Language Model）的检索增强生成技术。这项技术通过结合检索机制，增强了大语言模型在处理复杂查询和生成更准确信息方面的能力。本文，综合分析了该领域的最新进展和未来趋势。

## [](#摘要)摘要

大语言模型 (大语言模型，LLMs) 虽展现出强大能力，但在实际应用中，例如在准确性、知识更新速度和答案透明度方面，仍存在挑战。检索增强生成 (Retrieval-Augmented Generation, RAG) 是指在利用大语言模型回答问题之前，先从外部知识库检索相关信息。

RAG 被证明能显著提升答案的准确性，并特别是在知识密集型任务上减少模型的错误输出。通过引用信息来源，用户可以核实答案的准确性，从而增强对模型输出的信任。

此外，RAG 有助于快速更新知识并引入特定领域的专业知识。

RAG 有效结合了大语言模型的参数化知识和非参数化的外部知识库，成为实施大语言模型的关键方法之一。本文概述了 RAG 在大语言模型时代的发展模式，总结了三种模式：初级 RAG、高级 RAG 和模块化 RAG。接着，本文梳理了 RAG 的三个主要组成部分：检索器、生成器和增强方法，以及每个部分的关键技术。同时，本文讨论了如何评估 RAG 模型的有效性，介绍了两种评估方法，强调了关键的评估指标和能力，并展示了最新的自动评估框架。最后，文章从垂直优化、水平扩展性和 RAG 的技术堆栈及生态系统三个方面，介绍了未来可能的研究方向。

## [](#1-引言)1 引言

大语言模型 (LLMs) 在自然语言处理 (NLP) 领域的表现远超以往任何模型。

GPT 系列模型\[Brown *et al.*, 2020, OpenAI, 2023\]、LLama 系列模型\[Touvron *et al.*, 2023\]、Gemini\[Google, 2023\] 等大语言模型，在多个评估基准上展现了卓越的语言掌握和知识理解能力，甚至超越了多项人类评估基准\[Wang *et al.*, 2019, Hendrycks *et al.*, 2020, Srivastava *et al.*, 2022\]。

然而，大语言模型也存在许多不足。

例如，它们可能产生不准确的信息\[Zhang *et al.*, 2023b\]，并在处理特定领域或高度专业化的查询时表现出知识缺失\[Kandpal *et al.*, 2023\]。当所需信息超出模型训练数据范围或需要最新数据时，大语言模型可能无法提供准确答案。这一限制在将生成式人工智能部署到真实世界生产环境中尤其成为挑战，因为仅依赖于黑盒式的大语言模型可能不够。

神经网络通常通过对模型进行微调来适应特定领域或专有信息，从而将知识参数化。尽管这种方法取得了显著成效，但它需要消耗大量计算资源，成本高昂，且需要专业技术知识，因此难以适应不断变化的信息环境。在这个过程中，参数化知识和非参数化知识各司其职。参数化知识是通过训练大语言模型（LLM）获得的，存储在神经网络的权重中，代表模型对训练数据的理解和泛化能力，是生成回应的基础。而非参数化知识则存储在外部的知识源，如向量数据库中，不直接编入模型，而是作为一种可更新的补充信息。非参数化知识使大语言模型能够访问和利用最新或特定领域的信息，提高回应的准确性和相关性。

纯参数化的语言模型（LLM）将其从大量语料库中学习到的世界知识储存在模型参数中。但这种模型存在局限性。首先，它难以保留训练语料库中的所有知识，特别是对于那些不太常见且具体的知识。其次，由于模型参数无法动态更新，参数化知识可能会随时间过时。最后，参数的增加会导致训练和推理的计算成本增加。为了解决纯参数化模型的局限，语言模型可以采取半参数化方法，将非参数化的语料库数据库与参数化模型相结合。这种方法被称为检索增强生成（Retrieval-Augmented Generation, RAG）。

“检索增强生成”（Retrieval-Augmented Generation, RAG）一词最早由 \[Lewis *et al.*, 2020\] 提出。它结合了一个预训练的检索器和一个预训练的序列到序列模型（生成器），通过端到端微调来以更可解释和模块化的方式捕获知识。在大型模型出现之前，RAG 主要专注于直接优化端到端模型。例如，在检索方面使用基于向量的密集通道检索（Dense Passage Retrieval, DPR）\[Karpukhin *et al.*, 2020\]，以及在生成方面训练较小的模型是常见的做法。

由于总体参数较少，检索器和生成器通常会进行同步的端到端训练或微调\[Izacard *et al.*, 2022\]。

随着像 ChatGPT 这样的大语言模型的出现，生成式语言模型在各种语言任务中展现出卓越的性能，得到了越来越多的关注和应用\[Bai *et al.*, 2022, OpenAI, 2023, Touvron *et al.*, 2023, Google, 2023\]。

然而，大语言模型 (LLMs) 仍面临诸如幻觉式错误 \[Yao *et al.*, 2023, Bang *et al.*, 2023\]、知识更新以及数据相关问题的挑战。

这些问题影响了大语言模型的可靠性，在一些严肃的任务场景中，尤其是在需要广泛知识的知识密集型任务，例如开放领域问题回答 \[Chen and Yih, 2020, Reddy *et al.*, 2019, Kwiatkowski *et al.*, 2019\] 和常识推理 \[Clark *et al.*, 2019, Bisk *et al.*, 2020\]，它们表现出了挑战。

模型参数中的隐含知识可能不够完整或不足。

后续研究发现，将 RAG 引入大模型的上下文学习 (In-Context Learning, ICL) 中，可以有效减轻上述问题，这种方法具有明显且易于实施的效果。在推理过程中，RAG 动态地从外部知识源中检索信息，并利用这些检索到的数据作为组织答案的参考。这极大地提高了答案的准确性和相关性，有效地解决了大语言模型中的幻觉式错误问题。这项技术自大语言模型出现以来迅速受到关注，已成为提升聊天机器人效能和增强大语言模型实用性的前沿技术之一。RAG 通过将事实知识与大语言模型的训练参数分离，巧妙地结合了生成模型的强大功能和检索模块的灵活性，为纯参数化模型中固有的知识不完整和不充分问题提供了有效的解决方案。

本论文系统地审视并分析了检索增强生成（RAG）的现有研究方法和未来发展道路，把它们归纳为三大范式：初级 RAG、高级 RAG 和模块化 RAG。接着，论文提供了关于三个核心组成部分的综合概述：检索（Retrieval）、增强（Augmented）、生成（Generation），强调了 RAG 的改进方向和目前的技术特色。在论述增强方法的章节中，将现有工作分为三个方面：RAG 的增强阶段、增强数据源以及增强过程。此外，论文还概述了与 RAG 相关的评估体系、适用场景等内容。通过阅读这篇文章，读者可以更全面、系统地理解大语言模型和检索增强生成的概念，深入了解知识检索增强的发展历程和关键技术，从而能够辨析不同技术的优缺点，找出适用的场景，并在实际中探索典型的应用案例。值得一提的是，Feng 等人\[2023b\] 在他们的研究中系统回顾了结合大语言模型与知识的方法、应用和未来趋势，特别关注了知识编辑和检索增强方法。Zhu 等人\[2023\] 则介绍了针对大语言模型的检索系统增强方面的最新进展，尤其关注检索系统本身。

同时，Asai 等人\[2023a\] 针对“什么”、“何时”、“如何”等问题，分析并阐释了基于检索的语言模型的关键步骤。与之相比，本文的目的是系统性地概述检索增强生成（RAG）的整个流程，并特别关注通过知识检索来增强大语言模型生成的研究。

![图 1：现有 RAG 研究的时间表。时间表主要根据发布日期确定。](/images/ai-series/rag/timeline.jpg)

图 1：现有 RAG 研究的时间表。时间表主要根据发布日期确定。

图 1 展示了 RAG 算法和模型的发展。在时间线上，大部分与 RAG 相关的研究出现在 2020 年之后，尤其是在 2022 年 12 月 ChatGPT 发布之后，这一事件成为了一个重要的转折点。ChatGPT 发布后，自然语言处理领域的研究进入了大模型时代。初级 RAG 技术迅速受到重视，相关研究的数量也随之激增。在增强策略方面，自 RAG 概念提出以来，预训练和监督微调阶段的强化研究一直在进行。然而，在大语言模型时代，推理阶段的强化研究开始增多。这主要是因为高性能大模型的训练成本很高。研究者们试图在推理阶段通过加入 RAG 模块，以成本效益的方式将外部知识整合进模型生成中。

在探讨增强数据的使用方面，早期的 RAG 主要致力于非结构化数据的应用，特别是在开放域问答环境中。随着时间的推移，RAG 检索的知识来源变得更加广泛，其中包括高质量数据。这些数据作为知识源，有效避免了如大模型误采纳错误信息和产生错误假设（即“幻觉”）的问题。值得一提的是，RAG 也开始利用结构化知识，如知识图谱。近期，自我检索成为热点，这指的是利用大语言模型自身的知识库来提升其性能。

本论文的接下来章节安排如下：第 2 章介绍 RAG 的背景知识。第 3 章探讨 RAG 的主流模式。第 4 章分析 RAG 中的检索器功能。第 5 章着重讲述 RAG 中的生成器如何工作。第 6 章强调介绍 RAG 中的数据增强方法。第 7 章讲解 RAG 的评估体系。第 8 章展望了 RAG 未来的发展方向。最后，在第 9 章中，我们总结了本次调研的主要内容。

## [](#2-背景)2 背景

本章节我们将介绍 RAG（一种模型优化技术）的定义，并将其与其他优化技术，如微调，进行对比。

### [](#21-定义)2.1 定义

在技术进步的背景下，RAG 的概念也随之拓展。在大语言模型 (Large Language Models) 的领域中，RAG 特指一种模式：模型在回答问题或生成文本时，首先从广阔的文档库中寻找相关信息。然后，模型使用这些找到的信息来生成回答或文本，从而提高其预测的准确度。RAG 的方法使得开发人员无需为每一个特定任务重新训练整个庞大的模型。他们可以简单地给模型加上一个知识库，通过这种方式增加模型的信息输入，从而提高回答的精确性。RAG 特别适用于那些需要大量知识的任务。简而言之，RAG 系统包括两个主要阶段：

1.  使用编码模型（如 BM25、DPR、ColBERT 等）根据问题找到相关的文档\[Robertson *et al.*, 2009, Karpukhin *et al.*, 2020, Khattab and Zaharia, 2020\]。
2.  生成阶段：以找到的上下文作为基础，系统生成文本。

![图 2：RAG 与其他模型优化方法的比较](/images/ai-series/rag/RAG_FT.png)

图 2：RAG 与其他模型优化方法的比较

### [](#22-rag-与微调)2.2 RAG 与微调

在大语言模型的优化过程中，除了 RAG，微调也是一种重要的技术。

可以把 RAG 想象成给模型提供一本教科书，让它根据特定的问题去查找信息。这种方法适用于模型需要解答具体问题或执行特定信息检索任务的情况。但 RAG 并不适合于教会模型理解广泛的领域或学习新的语言、格式或风格。

而微调更像是让学生通过广泛学习来吸收知识。

当模型需要模仿特定的结构、风格或格式时，微调就显得非常有用。它可以提高未经微调的模型的表现，使交互更加高效。

微调特别适用于强化模型已有的知识、调整或定制模型的输出，以及给模型下达复杂的指令。然而，微调并不适合于向模型中添加新的知识，或者在需要快速迭代新场景的情况下使用。

微调 (Fine-tuning) 的过程就像是让学生通过深入持久的学习来吸收知识。这种方法适用于在模型需要精确模仿特殊的结构、艺术风格或者格式时。微调能够使模型的表现超越未经微调的模型，并提升交互效率。它尤其适合于突出模型基础知识库中已有的知识，调整或定制模型输出，并以复杂的指引来训练模型。然而，微调并不适合于向模型中增加全新的知识，或应对那些需要快速迭代新场景的情况。RAG (Retrieval-Augmented Generation) 和微调 (Fine-tuning) 的具体比较可以参见表 1。

RAG 和微调可以相互补充，而非相互排斥，从而在不同层次上增强模型的能力。在特定情况下，结合这两种方法可以达到模型性能的最佳状态。整个利用 RAG 和微调进行优化的过程可能需要多轮迭代才能获得满意的成果。

目前的研究已经表明，检索增强生成 (Retrieval-Augmented Generation, RAG) 在优化大语言模型 (Large Language Model) 方面，相较于其他方法具有显著的优势【Shuster *et al.*, 2021; Yasunaga *et al.*, 2022; Wang *et al.*, 2023c; Borgeaud *et al.*, 2022】：

+   RAG 通过关联外部知识来提高答案的准确性，有效减少了语言模型中出现的虚假信息，使得生成的回答更加准确可信。
+   使用检索技术能够识别到最新的信息，这使得 RAG 在保持回答的及时性和准确性方面，相较于只依赖训练数据的传统语言模型有明显优势。
+   RAG 的透明度是其一大优点。通过引用信息来源，用户可以核实答案的准确性，这增强了人们对模型输出结果的信任。
+   RAG 具备高度的定制化能力。通过索引与特定领域相关的文本语料库，RAG 能够为不同领域提供专业的知识支持。
+   在安全性和隐私管理方面，RAG 通过数据库中设置的角色和安全控制，实现了对数据使用的更好控制。相比之下，经过微调的模型在管理数据访问权限方面可能不够明确。
+   RAG 在处理大规模数据集方面更具有扩展性。它无需更新所有参数和创建新的训练集，因此在经济效率方面更具优势。
+   最后，RAG 提供的结果更加值得信赖。RAG 从最新数据中提取确定性的结果，而经过微调的模型在处理动态数据时可能会产生错误信息和不准确之处，缺乏透明度和可信度。

## [](#3-rag-框架)3 RAG 框架

RAG 研究范式在不断演变。本章重点介绍 RAG 研究范式的发展历程。我们将其分为三种类型：初级 RAG、高级 RAG 和模块化 RAG。虽然早期的 RAG 在成本效益上表现良好，并且性能优于传统的大语言模型 (LLM)，但它仍面临着诸多挑战。高级 RAG 和模块化 RAG 的设计是为了解决原始 RAG (Naive RAG) 的特定不足。

|  |  |  |
| --- | --- | --- |
| 特征比较 | RAG | 微调 (Fine-tuning) |
| 知识更新 | 直接更新检索知识库，确保信息持续更新，无需频繁重新训练，非常适合动态变化的数据环境。 | 存储静态数据，需要重新训练用于知识和数据的更新。 |
| 外部知识 | 擅长利用外部资源，特别适合处理文档或其他结构化/非结构化数据库。 | 可用于将预训练中外部学习到的知识与大语言模型保持一致，但对于频繁变化的数据源可能不太实用。 |
| 数据处理 | 对数据的处理和操作要求极低。 | 依赖于构建高质量的数据集，有限的数据集可能无法显著提高性能。 |
| 模型定制 | 侧重于信息检索和融合外部知识，但可能无法充分定制模型行为或写作风格。 | 允许根据特定风格或术语调整 LLM 行为、写作风格或特定领域知识。 |
| 可解释性 | 答案能够追溯到具体的数据来源，提供更高的可解释性和可追踪性。 | 就像一个黑盒子，并不总是清楚模型为什么会做出某种反应，可解释性相对较低。 |
| 计算资源 | 需要计算资源来支持检索策略和数据库相关技术。外部数据源的整合和更新需保持维护。 | 有必要准备和整理高质量的训练数据集，确定微调目标，并提供相应的计算资源。 |
| 延迟要求 | 因涉及数据检索，可能带来较高的延迟。 | 经过微调的大语言模型 (LLM) 可以不通过检索直接回应，降低延迟。 |
| 降低幻觉 | 由于每个回答都基于检索到的实际证据，因此本质上更不容易产生错误或虚构的回答。 | 根据特定领域的数据训练模型，有助于减少幻觉，但面对未训练过的输入时仍可能出现幻觉。 |
| 伦理和隐私问题 | 从外部数据库存储和检索文本可能引起伦理和隐私方面的担忧。 | 训练数据中的敏感内容可能会引起伦理和隐私方面的问题。 |

表 1: RAG 与微调之间的对比

### [](#31-原始-rag-naive-rag)3.1 原始 RAG (Naive RAG)

原始 RAG (Naive RAG) 代表了早期研究方法，在 ChatGPT 广泛应用后迅速崭露头角。原始 RAG 的流程包括传统的索引、检索和生成步骤。原始 RAG 也被概括为一个“检索” - “阅读”框架 \[Ma *et al.*, 2023a\]。

**索引**

指的是在离线状态下，从数据来源处获取数据并建立索引的过程。具体而言，构建数据索引包括以下步骤：

1.  **数据索引：** 包括清理和提取原始数据，将 PDF、HTML、Word、Markdown 等不同格式的文件转换成纯文本。
    
2.  **分块：** 将加载的文本分割成更小的片段。由于语言模型处理上下文的能力有限，因此需要将文本划分为尽可能小的块。
    
3.  **嵌入和创建索引：** 这一阶段涉及通过语言模型将文本编码为向量的过程。所产生的向量将在后续的检索过程中用来计算其与问题向量之间的相似度。由于需要对大量文本进行编码，并在用户提问时实时编码问题，因此嵌入模型要求具有高速的推理能力，同时模型的参数规模不宜过大。完成嵌入之后，下一步是创建索引，将原始语料块和嵌入以键值对形式存储，以便于未来进行快速且频繁的搜索。
    

**检索：**

根据用户的输入，采用与第一阶段相同的编码模型将查询内容转换为向量。系统会计算问题向量与语料库中文档块向量之间的相似性，并根据相似度水平选出最相关的前 K 个文档块作为当前问题的补充背景信息。

**生成：**

将给定的问题与相关文档合并为一个新的提示信息。随后，大语言模型（LLM）被赋予根据提供的信息来回答问题的任务。根据不同任务的需求，可以选择让模型依赖自身的知识库或仅基于给定信息来回答问题。如果存在历史对话信息，也可以将其融入提示信息中，以支持多轮对话。

**朴素 RAG 的挑战：**

朴素 RAG 主要在三个方面面临挑战：检索质量、回应生成质量和增强过程。

+   **检索质量：** 该方面的问题多方面。最主要的问题是低精度，即检索集中的文档块并不都与查询内容相关，这可能导致信息错误或不连贯。其次是低召回率问题，即未能检索到所有相关的文档块，使得大语言模型无法获取足够的背景信息来合成答案。此外，过时信息也是一个挑战，因为数据冗余或过时可能导致检索结果不准确。
    
+   **回应生成质量：** 这方面的问题同样多样。最突出的问题是制造错误信息，即模型在缺乏足够上下文的情况下虚构答案。另一个问题是回答不相关，即模型生成的答案未能针对查询问题。进一步来说，生成有害或偏见性回应也是一个问题。
    
+   **增强过程：** 最终，增强过程面临几个重要挑战。特别重要的是，如何将检索到的文段的上下文有效融入当前的生成任务。如果处理不得当，生成的内容可能显得杂乱无章。当多个检索到的文段包含相似信息时，冗余和重复成为问题，这可能导致生成内容的重复。此外，如何判断多个检索到的文段对生成任务的重要性或相关性非常有挑战性，增强过程需要恰当地评估每个文段的价值。检索到的内容可能具有不同的写作风格或语调，增强过程需调和这些差异，以确保最终输出的一致性。最后，生成模型可能会过度依赖于增强信息，导致生成的内容仅是重复检索到的信息，而缺乏新的价值或综合信息。
    

### [](#32-高级-rag)3.2 高级 RAG

为了克服 Naive RAG 的局限性，高级 RAG 进行了针对性的改进。在检索生成质量方面，高级 RAG 引入了预检索和后检索的方法。它还通过滑动窗口、细粒度分割和元数据等手段优化了索引，以解决 Naive RAG 所遇到的索引问题。同时，高级 RAG 也提出了多种优化检索流程的方法。在具体实施上，高级 RAG 可以通过流水线方式或端到端的方式进行调整。

#### [](#预检索处理)预检索处理

+   **优化数据索引** 优化数据索引旨在提高索引内容的质量。目前主要采用五种策略：提升索引数据粒度、优化索引结构、增加元数据、对齐优化以及混合检索。
    
    1.  **提升数据粒度：** 在索引前的优化是为了改进文本的标准化和一致性，确保事实准确和上下文丰富，从而保障 RAG 系统的表现。文本标准化意在剔除无关信息和特殊字符，提升检索效率。在确保一致性方面，主要是消除术语和实体的歧义，剔除重复或冗余信息，简化检索过程。事实的准确性至关重要，应尽可能验证每项数据。在保持上下文方面，通过添加特定领域的注释和用户反馈循环不断更新，使系统适应现实世界的交互上下文。考虑时间敏感性，应更新过时文档。总的来说，优化索引数据的重点在于清晰度、上下文和正确性，以提高系统的效率和可靠性。以下是一些最佳实践。
        
    2.  **优化索引结构：** 通过调整数据块大小、改变索引路径和加入图结构信息可以实现这一目标。调整数据块大小的方法是尽可能多地收集相关上下文，同时尽量减少干扰。在构建 RAG 系统时，块大小是关键参数。不同的评估框架用于比较不同块的大小。[LlamaIndex](https://www.llamaindex.ai) 利用 GPT4 评估数据的保真度和相关性，LLaMA\[Touvron *et al.*, 2023\] 索引能自动评估不同块化方法的效果。跨多个索引路径查询与之前的元数据过滤和块化方法紧密相关，可能涉及同时在不同索引中进行查询。标准索引可用于特定查询，或使用独立索引基于元数据关键词（如“日期”索引）进行搜索或过滤。引入图结构是将实体转化为节点，将它们之间的关系转化为关联，这可以通过利用节点间的关系来提高对多跳问题的准确性。使用图数据索引能提高检索的相关性。
        
    3.  **添加元数据信息：** 这一策略的核心是将引用的元数据，如日期和用途（用于筛选）等，嵌入到数据块中。添加如章节和引用小节等元数据，对于提升检索效率是有益的。当索引被分割成多个块时，如何高效检索便成为关键。通过元数据进行初步筛选可以提高检索的效率和准确性。
        
    4.  **对齐优化：** 该策略主要针对不同文档之间的对齐问题和差异。对齐的核心思想是引入“假设性问题”，即创建适合用每篇文档回答的问题，并将这些问题与文档结合起来。这种做法有助于解决文档间的对齐问题和不一致性。
        
    5.  **混合检索：** 混合检索的优势在于它结合了不同检索技术的长处。它智能地融合了关键词搜索、语义搜索和向量搜索等多种技术，适应不同类型的查询需求，确保能够一致地检索到最相关和内容丰富的信息。混合检索作为检索策略的重要补充，能够显著提升 RAG 流程的整体性能。
        

#### [](#嵌入-embedding)嵌入 (Embedding)

+   **微调嵌入：** 微调嵌入模型的调整直接影响到 RAG 的有效性。微调的目的是让检索到的内容与查询之间的相关性更加紧密。微调嵌入的作用可以比作在语音生成前对“听觉”进行调整，优化检索内容对最终输出的影响。通常，微调嵌入的方法可以分为针对特定领域上下文的嵌入调整和检索步骤的优化。特别是在处理不断变化或罕见术语的专业领域，这些定制化的嵌入方法能够显著提高检索的相关性。BGE\[BAAI, 2023\]嵌入模型是一个经过微调的高性能嵌入模型，例如由 BAAI 3 开发的 BGE-large-EN。为了对 BGE 模型进行微调，首先使用诸如 gpt-3.5-turbo 这样的大语言模型（LLM）根据文档块制定问题，其中问题和答案（文档块）构成了微调过程中的训练对。
    
+   **动态嵌入（Dynamic Embedding）**：不同于静态嵌入（static embedding），动态嵌入根据单词出现的上下文进行调整，为每个单词提供不同的向量表示。例如，在 Transformer 模型（如 BERT）中，同一单词根据周围词汇的不同，其嵌入也会有所变化。研究发现，在 OpenAI 的 text-embeddingada-002 模型中，文本长度小于 5 个 Token 时，常出现意外高的余弦相似度。理想的嵌入应该包含足够的上下文，以保证良好的结果。OpenAI 的 embeddings-ada-02 是基于大语言模型（如 GPT）原理开发的，比传统静态嵌入模型更复杂，能够捕捉一定程度的上下文。尽管它在上下文理解方面表现出色，但可能不如最新的大语言模型（如 GPT-4）那样对上下文敏感。
    

#### [](#检索后处理流程)检索后处理流程

在从数据库中检索出有价值的上下文后，将其与查询内容合并输入到大语言模型（LLM）会遇到挑战。一次性向大语言模型展示所有相关文档可能会超出其处理的上下文窗口限制。将多个文档拼接成一个冗长的检索提示不仅效率低，还会引入噪声，影响大语言模型聚焦关键信息。因此，需要对检索到的内容进行额外处理，以解决这些问题。

+   **ReRank（重新排序）**：重新排序，将最相关的信息置于提示的前后边缘，是一个简单直接的方法。这一思路已在如 LlamaIndex、LangChain 和 HayStack 等框架中得到应用\[Blagojevi, 2023\]。例如，Diversity Ranker 会根据文档的多样性进行重新排序，而 LostInTheMiddleRanker 则会交替地将最佳文档放在上下文窗口的开始和结束位置。同时，为了应对基于向量的语义相似度模拟搜索的挑战，方法如 cohereAI rerank \[Cohere, 2023\]、bgererank5 或 LongLLMLingua \[Jiang *et al.*, 2023a\]，会重新计算相关文本与查询之间的语义相似度。
    
+   **Prompt 压缩**：研究显示，检索文档中的噪音会对 RAG 性能产生不利影响。在处理的后期阶段，我们主要关注于压缩无关紧要的上下文，凸显关键段落，并缩短整体的上下文长度。例如 Selective Context\[Litman *et al.*, 2020\] 和 LLMLingua \[Anderson *et al.*, 2022\]等方法，它们运用小型语言模型来计算提示之间的互信息或困惑度，以此估算各个元素的重要性。
    
    不过，在 RAG 或者长篇上下文的情境中，这些方法可能会遗失关键信息。
    
    Recomp \[Xu *et al.*, 2023a\]通过训练不同精细程度的压缩器来应对这一问题。
    
    在处理长篇上下文 \[Xu *et al.*, 2023b\]时，这种方法通过分解和压缩来处理大量的上下文内容，而“在记忆迷宫中漫步”\[Chen *et al.*, 2023a\]则设计了一个分层次的总结树来增强大语言模型（LLM）对关键信息的感知能力。
    
+   **RAG 管道优化：** 检索过程的优化旨在提升 RAG 系统的效率和信息质量。当前的研究主要集中在智能结合不同的搜索技术，优化检索步骤，引入认知回溯概念，灵活运用多样化的查询策略，并利用嵌入式相似度。这些努力共同追求在 RAG 检索中达到效率与上下文信息丰富度的平衡。
    
+   **混合搜索的探索：** RAG 系统巧妙结合了基于关键词、语义以及向量的多种搜索技术。这种综合方法让 RAG 系统能够应对不同的查询类型和信息需求，有效地获取最相关且内容丰富的信息。混合搜索作为一种强大的补充手段，显著提升了 RAG 流程的整体表现。
    
+   **递归检索与查询引擎：** 在 RAG 系统中，采用递归检索和高级查询引擎是提高检索效果的另一有效手段。递归检索的首要步骤是在初始阶段获取小型文档块，以便抓住关键语义。随后，该过程会提供更大的文档块，为大语言模型 (LM) 提供更丰富的上下文信息。这种双重检索策略既保证了效率，又能提供深入的上下文回应。
    
+   **StepBack-prompt 方法：** 集成到 RAG 流程中的 StepBack-prompt 方法\[Zheng *et al.*, 2023\] 促使大语言模型 (LLM) 在处理具体案例时能够退一步，转而思考背后的普遍概念或原则。研究发现，这种结合后向提示的方法在处理各种复杂、推理密集的任务时表现卓越，充分展现了其与 RAG 的良好兼容性。这种方法既能用于后向提示的答案生成，也能用于最终的问答环节。
    
+   **子查询：** 根据不同场景，我们可以采取多种查询策略，如使用 LlamaIndex 等框架提供的查询引擎、树状查询、向量查询或基本的块序列查询。
    
+   **HyDE 方法：** 这种方法基于一个假设：相较于直接查询，通过大语言模型 (LLM) 生成的答案在嵌入空间中可能更为接近。HyDE 首先响应查询生成一个假设性文档（答案），然后将其嵌入，并利用此嵌入去检索与假设文档类似的真实文档。这种方法强调答案之间的嵌入相似性，而非单纯依赖于查询的嵌入相似性。但在某些情况下，特别是当语言模型对话题不够熟悉时，它可能导致错误实例的增加。
    

![图 3：三种 RAG 范式的比较](/images/ai-series/rag/fram_compare.png)

图 3：三种 RAG 范式的比较

#### [](#模块化-rag)模块化 RAG

模块化 RAG 结构打破了传统的“原始 RAG”框架，这个框架原本涉及索引、检索和生成，现在提供了更广泛的多样性和更高的灵活性。它不仅集成了各种方法来丰富功能模块，比如在相似性检索中加入了搜索模块，并且在检索器中采用了微调 (fine-tuning) 策略\[Lin *et al.*, 2023\]。特别的问题也催生了重构后的 RAG 模块\[Yu *et al.*, 2022\]，以及类似 \[Shao *et al.*, 2023\] 的迭代方法。这种模块化的 RAG 范式正逐渐成为 RAG 领域的趋势，它支持从序列化流程到跨多个模块的端到端训练方法。三种 RAG 范式的对比在图 3 中进行了详细展示。

##### [](#新模块)新模块

+   **搜索模块：** 与简单/高级 RAG 的查询和语料间的常规相似性检索不同，这个特定场景下的搜索模块融合了直接在（附加的）语料库中进行搜索的方法。这些方法包括利用大语言模型（LLM）生成的代码、SQL、Cypher 等查询语言，或是其他定制工具。其搜索数据源多样，涵盖搜索引擎、文本数据、表格数据或知识图等\[Wang *et al.*, 2023c\]。
    
+   **记忆模块：** 本模块充分利用大语言模型本身的记忆功能来引导信息检索。其核心原则是寻找与当前输入最为匹配的记忆。例如，Self-mem \[Cheng *et al.*, 2023b\]通过迭代使用增强检索的生成模型，创建了一个结合了“原始问题”和“双重问题”的无限记忆池。这种增强检索的生成模型能够利用其自身的输出来自我提升，在推理过程中使文本更加贴近数据分布，而非仅依赖训练数据\[Wang *et al.*, 2022a\]。
    
+   **额外生成模块：** 面对检索内容中的冗余和噪声问题，这个模块通过大语言模型生成必要的上下文，而非直接从数据源进行检索\[Yu *et al.*, 2022\]。通过这种方式，由大语言模型生成的内容更可能包含与检索任务相关的信息。
    
+   **任务适应模块：** 该模块致力于将 RAG 调整以适应各种下游任务。例如，UPRISE\[Cheng *et al.*, 2023a\]能够自动从预先构建的数据池中为给定的零样本任务输入检索出适当的提示，从而提升任务和模型间的通用性。PROMPTAGATOR\[Dai *et al.*, 2022\]则利用大语言模型作为少样本查询生成器，基于生成的数据创建针对特定任务的检索器。利用大语言模型的泛化能力，PROMPTAGATOR 使得仅凭几个示例就可以创建专门针对特定任务的端到端检索器。
    
+   **对齐模块：** 在 RAG 的应用中，查询与文本之间的对齐一直是影响效果的关键因素。在模块化 RAG 的发展中，研究者们发现，在检索器中添加一个可训练的 Adapter 模块能有效解决对齐问题。例如，PRCA\[Yang *et al.*, 2023b\]通过强化学习训练了一个由大语言模型奖励驱动的上下文适配器，该适配器位于检索器和生成器之间。通过在标注的自回归策略中的强化学习阶段，它能够优化检索到的信息，实现在强化学习过程中最大化奖励。
    
    AAR\[Yu *et al.*, 2023b\] 提出了一种通用插件，这种插件能从已知来源的大语言模型 (LLM) 学习到语言模型的偏好，并用这些知识来辅助那些未知或尚未共同微调的大语言模型。
    
    RRR\[Ma *et al.*, 2023a\] 设计了一个基于强化学习的模块，该模块能够重写查询，使得这些查询更好地与语料库中的文档相匹配。
    
+   **验证模块：** 在现实世界中，我们无法总是保证检索到的信息的可靠性。检索到不相关的数据可能会导致大语言模型产生错误信息。因此，可以在检索文档后加入一个额外的验证模块，以评估检索到的文档与查询之间的相关性，这样做可以提升 RAG\[Yu *et al.*, 2023a\] 的鲁棒性。
    

#### [](#新模式-modular)新模式 Modular

RAG 的组织方法具有高度灵活性，能够根据特定问题的上下文，对 RAG 流程中的模块进行替换或重新配置。在基础的 Naive RAG 中，包含了检索和生成这两个核心模块（有些文献中称之为阅读或合成模块），这个框架因而具备了高度的适应性和多样性。目前的研究主要围绕两种组织模式：一是增加或替换模块，二是调整模块间的工作流程。

+   **增加或替换模块** 在增加或替换模块的策略中，我们保留了原有的检索 - 阅读结构，同时加入新模块以增强特定功能。 RRR\[Ma *et al.*, 2023a\] 提出了一种重写 - 检索 - 阅读的流程，其中利用大语言模型（LLM）的性能作为强化学习中重写模块的奖励机制。这样，重写模块可以调整检索查询，从而提高阅读器在后续任务中的表现。同样地，我们也可以在其他方法中选择性地替换模块，例如在生成 - 阅读\[Yu *et al.*, 2022\]中，大语言模型的生成模块取代了检索模块。 背诵 - 阅读\[Sun *et al.*, 2022\] 则是将传统的外部检索转变为从模型权重中检索，首先由大语言模型记忆与任务相关的信息，然后生成处理知识密集型自然语言处理任务所需的输出。
    
+   **调整模块间的工作流程** 在调整模块间流程的领域，重点在于加强语言模型与检索模型之间的互动。DSP\[Khattab *et al.*, 2022\] 引入了展示 - 搜索 - 预测的框架，将上下文学习系统视为一个明确的程序，而不是简单的终端任务提示，以此来应对知识密集型的任务。 ITER-RETGEN\[Shao *et al.*, 2023\] 则是使用生成内容来指导检索，通过迭代执行“检索增强生成”和“生成增强检索”，形成一种检索 - 阅读 - 检索 - 阅读的工作流。Self-RAG\[Asai *et al.*, 2023b\] 则采用决策 - 检索 - 反思 - 阅读的流程，引入了一个用于主动判断的模块。这种适应性和多样性的方法使得在 Modular RAG 框架中可以动态地组织各种模块。
    

## [](#4-检索器)4 检索器

在 RAG（检索增强生成）技术中，“R”代表检索，其作用是从大量知识库中检索出最相关的前 k 个文档。然而，构建一个高质量的检索器是一项挑战。在本章，我们将探讨三个关键问题：1) 如何获得准确的语义表示？2) 如何匹配查询和文档的语义空间？3) 如何让检索器的输出与大语言模型（LLM）的偏好相协调？

### [](#41-如何获得准确的语义表示)4.1 如何获得准确的语义表示？

在 RAG 中，语义空间指的是查询和文档被映射的多维空间。

进行检索时，我们是在这个语义空间内进行评估的。如果语义表达不准确，对 RAG 的影响将是灾难性的。本节将介绍两种构建准确语义空间的方法。

#### [](#块优化)块优化

处理外部文档的第一步是分块，以获得更细致的特征。接着，这些文档块被嵌入（Embedded）。

嵌入太大或太小的文本块可能无法取得最佳效果。因此，找到适合语料库文档的最佳块大小至关重要，以确保搜索结果的准确性和相关性。

选择分块策略时，需要考虑的要素包括：被索引内容的特点、使用的嵌入模型及其最适块大小、用户查询的预期长度和复杂度、以及检索结果在特定应用中的使用方式。例如，对于不同长度的内容，应选用不同的分块模型。不同的嵌入模型，如 Sentence-Transformer 和 text-embedding-ada-002，在处理不同大小的文本块时效果各异；例如，Sentence-Transformer 更适合单句处理，而 text-embedding-ada-002 更适合处理包含 256 或 512 Token 的文本块。用户问题文本的长度和复杂性，以及应用程序的特定需求（如语义搜索或问答），也会影响分块策略的选择。这可能与选用的大语言模型的 Token 限制直接相关，因此可能需要调整块大小。实际上，准确的查询结果是通过灵活应用多种分块策略来实现的，并没有最佳策略，只有最适合的策略。

当前的 RAG 研究采用了多种块优化方法，以提高检索的效率和准确性。其中，技术如滑动窗口技术通过多次检索，聚合全局相关信息，实现分层检索。

Small2big 技术在搜索过程中使用小文本块，并为语言模型提供更大的相关文本块进行处理。摘要嵌入（Abstract embedding）技术对文档摘要执行 Top K 检索，以提供完整的文档上下文。元数据过滤（Metadata Filtering）技术通过文档的元数据进行过滤。图索引（Graph Indexing）技术把实体和关系转化为节点和连接，这在处理多跳问题时显著提升了相关性。这些方法的结合显著提升了 RAG 的检索效果和性能。

#### [](#微调嵌入模型)微调嵌入模型

在确定了 Chunk 的适当大小之后，我们需要通过一个嵌入模型（Embedding model）将 Chunk 和查询嵌入到语义空间中。因此，嵌入模型是否能有效代表整个语料库变得极其重要。如今，一些出色的嵌入模型已经问世，例如 UAE\[AngIE, 2023\]、Voyage\[VoyageAI, 2023\]、BGE\[BAAI, 2023\] 等，它们在大规模语料库上预训练过。但在特定领域中应用时，这些模型可能无法准确地反映领域特定的语料信息。此外，为了确保模型能够理解用户查询与内容的相关性，对嵌入模型进行任务特定的微调至关重要，否则未经微调的模型可能无法满足特定任务的需求。因此，对嵌入模型进行微调对于其下游应用是必不可少的。

#### [](#领域知识微调)领域知识微调

嵌入模型微调的两个基本范式包括领域知识微调。为了让嵌入模型准确理解领域特定信息，我们需要构建专门的领域数据集来对嵌入模型进行微调。

然而，嵌入模型的微调与常规语言模型的微调不同，主要区别在于所使用的数据集。当前微调嵌入模型的主流方法使用的数据集包括查询（Queries）、语料库（Corpus）和相关文档（Relevant Docs）。嵌入模型基于查询在语料库中检索相关文档，然后根据查询的相关文档是否命中作为衡量模型的标准。

在构建数据集、微调模型和评估过程中，每个部分都可能遇到各种挑战。LlamaIndex \[Liu, 2023\] 专门为嵌入模型的微调过程引入了一系列关键类别和功能，大大简化了这一过程。通过准备领域知识的语料库并利用其提供的方法，我们可以轻松获得适合特定领域需求的专业嵌入模型。

#### [](#对下游任务的微调)对下游任务的微调

根据下游任务微调嵌入模型同样重要。使用 RAG 处理特定任务时，已有研究通过大语言模型 (LLM) 的功能来微调嵌入模型。例如，PROMPTAGATOR\[Dai *et al.*, 2022\] 将大语言模型用作少样本查询生成器，基于此生成的数据创建了针对特定任务的检索器，这样做可以解决一些领域由于数据不足而难以进行常规监督微调的问题。LLM-Embedder\[Zhang *et al.*, 2023a\] 则利用大语言模型为多个特定任务中的数据输出奖励值，并通过硬性标记数据集和来自 LLM 的软性奖励对检索器进行了双重微调。

这种做法在一定程度上通过引入领域知识和针对特定任务的微调，改善了语义表达。但是，这种训练方式得到的检索器并不总是直接有益于大语言模型，因此有研究通过从 LLM 获取反馈信号，直接对嵌入模型进行了监督微调。（更多细节将在第 4.4 节介绍）

### [](#42-如何协调查询和文档的语义空间)4.2 如何协调查询和文档的语义空间

在 RAG 应用中，有些检索器用同一个嵌入模型来处理查询和文档，而有些则使用两个不同的模型。此外，用户的原始查询可能表达不清晰或缺少必要的语义信息。因此，协调用户的查询与文档的语义空间显得尤为重要。本节将介绍两种关键技术，帮助实现这一目标。

#### [](#查询重写)查询重写

一种直接的方式是对查询进行重写。

如 Query2Doc\[Wang *et al.*, 2023b\] 和 ITER-RETGEN\[Shao *et al.*, 2023\] 所指出的，可以利用大语言模型的能力生成一个指导性的伪文档，然后将原始查询与这个伪文档结合，形成一个新的查询。

而在 HyDE\[Gao *et al.*, 2022\] 中，则是通过文本标识符来建立查询向量，利用这些标识符生成一个相关但可能并不存在的“假想”文档，它的目的是捕捉到相关的模式。

Ma 团队于 2023 年提出的 RRR 框架，开创了一种新的方法，将检索和阅读的顺序进行了反转，专注于如何重新编写查询。在这个方法中，首先利用大语言模型来生成搜索查询，然后通过网络搜索引擎找到相关信息，最后用一个小型的语言模型来帮助这个大模型进行所谓的“训练重写”，以提高其效果。Zheng 团队在 2023 年提出的 STEP-BACKPROMPTING 方法，能够使大语言模型进行更深层次的抽象思考，抽取出关键的概念和原则，并基于这些进行信息检索。

此外，多查询检索方法让大语言模型能够同时产生多个搜索查询。这些查询可以同时运行，它们的结果一起被处理，特别适用于那些需要多个小问题共同解决的复杂问题。

#### [](#嵌入变换)嵌入变换

对于嵌入变换，除了像查询重写这样的宏观方法，还有一些更微观的技术。在 Liu 于 2023 年提出的 LlamaIndex 中，研究者们通过在查询编码器后加入一个特殊的适配器，并对其进行微调，从而优化查询的嵌入表示，使之更适合特定的任务。

在处理结构不同的查询和文档时，例如非结构化的查询和结构化的文档，使两者对齐变得至关重要。Li 团队在 2023 年提出的 SANTA 方法，就是为了让检索系统能够理解并处理结构化的信息。他们提出了两种预训练方法：一是利用结构化与非结构化数据之间的自然对应关系进行对比学习；二是采用了一种围绕实体设计的掩码策略，让语言模型来预测和填补这些被掩盖的实体信息。

### [](#43-调整检索器结果以适应大语言模型的需求)4.3 调整检索器结果以适应大语言模型的需求

在 RAG（Retrieval-Augmented Generation）流程中，即便我们采用各种技术提升检索效果，最终对 RAG 的整体性能可能仍无明显提升。原因在于检索到的文档可能并不符合大语言模型（LLM）的需求。本节将介绍两种方法，以使检索器的输出更好地符合 LLM 的偏好。

**LLM 监督下的训练** 众多研究通过从大语言模型获取的反馈信号来调整嵌入模型。AAR\[20\] 通过一种基于编解码器架构的语言模型（LM），为预训练的检索器提供监督信号。检索器通过分析 LM 偏好的文档（基于 FiD 的交叉注意力分数），进行微调，使用了“硬负样本采样”和传统的交叉熵损失方法。经过这样的训练，检索器能直接用于提升新的目标 LLM，在相关任务中取得更好的成绩。检索器的训练损失公式如下：

ζ\=∑q∑d+∈Da+∑d−∈D−l(f(q,d+),f(q,d−))\\zeta = \\sum\_{q} \\sum\_{d^{+} \\in D^{a^{+}}} \\sum\_{d^{-}\\in D^{-}} l\\left ( f\\left ( q,d^{+} \\right ),f\\left ( q,d^{-} \\right ) \\right )ζ\=q∑​d+∈Da+∑​d−∈D−∑​l(f(q,d+),f(q,d−))

其中，Da+D^{a^{+}}Da+ 是 LLM 偏好的文档集，Da−D^{a^{-}}Da− 则是不受偏好的文档集。lll 代表传统的交叉熵损失函数。研究最后指出，LLM 可能更倾向于关注易于阅读而非信息量丰富的文档。

REPLUG\[14\] 则通过结合检索器和 LLM 计算出的文档概率分布，采用监督训练方式。训练过程中，通过计算 KL 散度来调整检索模型，使其性能得到提升。这种方法简单有效，利用 LM 作为监督信号，无需依赖特定的交叉注意力机制。检索器的训练损失公式如下：

ζ\=1∣D∣∑x∈DKL(PR(d∣x)∣∣QLM(d∣x,y))\\zeta = \\frac{1}{\\left| D \\right|} \\sum\_{x \\in D }KL\\left ( P\_{R}\\left ( d|x \\right )||Q\_{LM}\\left ( d|x,y \\right ) \\right )ζ\=∣D∣1​x∈D∑​KL(PR​(d∣x)∣∣QLM​(d∣x,y))

这里，D 表示输入上下文集合，PR 是文档的检索可能性，QLM 则是每份文档基于 LM 的概率。

UPRISE\[Cheng *et al.*, 2023a\] 同样采用了冻结的大语言模型来对 Prompt Retriever 进行微调。

在这些研究中，无论是语言模型还是检索器，它们都以提示输入对作为输入。这些模型使用大语言模型 (Large Language Model) 提供的分数来指导检索器的训练，这相当于用大语言模型来对数据集进行标注。

Atlas\[Izacard *et al.*, 2022\] 提出了四种微调监督嵌入模型的方法。其中之一，注意力蒸馏 (Attention Distillation)，通过语言模型在生成输出时产生的跨注意力分数来进行学习。而 EMDR2 则运用期望最大化 (Expectation-Maximization) 算法，将检索到的文档作为隐藏变量，进行模型训练。困惑度蒸馏 (Perplexity Distillation) 直接利用模型生成的 Token 的困惑度 (perplexity) 作为训练指标。LOOP 则引入了一种新的基于文档删除对大语言模型预测影响的损失函数，这为模型更好地适应特定任务提供了有效的训练方法。

**插入适配器**

然而，微调嵌入模型可能会遇到一些挑战，例如使用 API 实现嵌入功能或本地计算资源不足。因此，一些研究选择外接适配器来进行模型对齐。PRCA\[Yang *et al.*, 2023b\] 在上下文提取阶段和奖励驱动阶段训练适配器，并通过基于 Token 的自回归 (autoregressive) 策略来优化检索器的输出。

TokenFiltering\[Berchansky *et al.*, 2023\] 的方法通过计算跨注意力分数，挑选出得分最高的输入 Token，有效地进行 Token 过滤。RECOMP\[Xu *et al.*, 2023a\] 提出了提取和生成压缩器的概念，这些压缩器通过选择相关的句子或合成文档信息来生成摘要，实现多文档查询聚焦摘要。此外，PKG\[Luo *et al.*, 2023\] 这一新颖方法，通过指令性微调将知识注入到一个白盒模型中，并直接替换了检索器模块，以便直接根据查询输出相关文档。

## [](#5-生成组件)5 生成组件

在 RAG 系统中，生成组件是核心部分之一，它的职责是将检索到的信息转化为自然流畅的文本。这一设计灵感源自于传统语言模型，但不同于一般的生成式模型，RAG 的生成组件通过利用检索到的信息来提高文本的准确性和相关性。在 RAG 中，生成组件的输入不仅包括传统的上下文信息，还有通过检索器得到的相关文本片段。这使得生成组件能够更深入地理解问题背后的上下文，并产生更加信息丰富的回答。此外，生成组件还会根据检索到的文本来指导内容的生成，确保生成的内容与检索到的信息保持一致。正是因为输入数据的多样性，我们针对生成阶段进行了一系列的有针对性工作，以便更好地适应来自查询和文档的输入数据。

### [](#51-如何通过后检索处理提升检索结果)5.1 如何通过后检索处理提升检索结果？

对于未经微调的大语言模型，多数研究依靠像 GPT-4\[OpenAI, 2023\] 这样的知名大语言模型，借助它们强大的内部知识库来全面检索文档信息。然而，这些大型模型仍然存在一些固有问题，比如上下文长度限制和对冗余信息的敏感性。为了解决这些问题，一些研究开始关注后检索处理。后检索处理指的是，在通过检索器从大型文档数据库中检索到相关信息后，对这些信息进行进一步的处理、过滤或优化。其主要目的是提高检索结果的质量，更好地满足用户需求或为后续任务做准备。可以将其理解为对检索阶段获得的文档进行二次处理。后检索处理通常包括信息压缩和结果的重新排序。

#### [](#信息压缩)信息压缩

信息压缩方面，即使检索器能够从庞大的知识库中提取相关信息，我们仍然面临处理大量检索文档信息的挑战。一些研究试图通过扩大大语言模型的上下文长度来解决这个问题，但当前的大模型还是受到上下文限制。在这种情况下，进行信息浓缩变得必要。总体来说，信息浓缩的重要性主要体现在减少信息噪音、解决上下文长度限制和提升生成效果等方面。

PRCA \[Yang *et al.*, 2023b\] 解决这一问题的方法是训练了一个信息提取器。在提取上下文的阶段，这个提取器能够根据给定的输入文本 SinputS\_{input}Sinput​，生成一个输出序列 CextractedC\_{extracted}Cextracted​，这个序列代表了输入文档中的精简上下文。训练的目标是让 CextractedC\_{extracted}Cextracted​ 尽可能接近实际的上下文 CtruthC\_{truth}Ctruth​。他们使用的损失函数定义如下：

minL(θ)\=−1N∑i\=1NCtruth(i)log(f.(Sinput(i);θ))min L(\\theta )=-\\frac{1}{N}\\sum\_{i=1}^{N} {C\_{truth}^{(i)}}log(f\_.(S\_{input}^{(i)};\\theta ))minL(θ)\=−N1​i\=1∑N​Ctruth(i)​log(f.​(Sinput(i)​;θ))

这里，f.f\_.f.​ 表示信息提取器的功能，而 θ\\thetaθ 是其参数。另一个项目 RECOMP\[11\] 采用了对比学习法来训练一个信息浓缩器。在每个训练样本中，会有一个正样本和五个负样本。该项目在此过程中采用了对比损失方法 \[13\] 来训练编码器。具体的优化目标表达如下：

−logesim(xi,pi)sim(xi,pi)+∑nj∈Niesim(xi,pi)\-log\\frac{e^{sim(x\_i,p\_i)}}{sim(x\_i,p\_i)+\\sum\_{n\_j\\in N\_i}e^{sim(x\_i,p\_i)}}−logsim(xi​,pi​)+∑nj​∈Ni​​esim(xi​,pi​)esim(xi​,pi​)​

其中 xix\_ixi​ 代表训练数据，pip\_ipi​ 是正样本，njn\_jnj​ 是负样本，sim(x,y) 用于计算 x 和 y 之间的相似度。还有一项研究则是致力于进一步减少文档的数量，以此提高模型回答问题的准确度。 \[Ma *et al.*, 2023b\] 提出了一种新的“Filter-Ranker”模式，它结合了大语言模型 (LLMs) 和小语言模型 (SLMs) 的优点。在这种模式下，SLMs 充当过滤器，LLMs 则作为排序器。通过激励 LLMs 对 SLMs 筛选出的难点样本进行重新排序，研究表明，这在各类信息提取 (IE) 任务中都取得了显著的提升。

#### [](#文档重排)文档重排

在文档重排过程中，重排模型的主要作用是优化由检索器检索出的文档集合。

当大语言模型 (LLM) 面临额外上下文的添加时，其性能往往会下降。为了应对这一挑战，重排序被提出作为一种行之有效的策略。其核心在于对文档记录进行重新组织，优先安排最相关的内容位于前列，同时将文档总量控制在一定数量之内。这种做法不仅有效缓解了检索时可能出现的上下文窗口扩大问题，也显著提升了检索的效率和响应速度\[Zhuang *et al.*, 2023\]。

重排序过程中引入的上下文压缩功能，目的是基于特定查询上下文直接筛选出相关信息。这一策略的独特之处在于，通过减少每个文档的内容量和筛选掉不相关的文档，它能更加集中地展示检索结果中的关键信息。因此，重排序模型在整个信息检索过程中起到了优化和精化的作用，为后续大语言模型的处理提供了更加有效和精准的输入。

### [](#52-如何优化生成器应对输入数据)5.2 如何优化生成器应对输入数据？

在 RAG 模型中，优化生成器是至关重要的。生成器负责将检索到的信息转化为相关文本，形成模型的最终输出。其优化目的在于确保生成文本既流畅又能有效利用检索文档，更好地回应用户的查询。

在一般的大语言模型 (LLM) 生成任务中，输入通常是个查询。而 RAG 的不同之处在于，输入不仅包括查询，还涵盖了检索器找到的多种文档（无论是结构化还是非结构化）。额外信息的加入对模型理解尤其是小型模型造成显著影响，因此，针对查询和检索文档的输入进行模型微调变得尤为重要。一般在将输入提供给微调过的模型之前，需要对检索器找到的文档进行后续处理。值得注意的是，RAG 中对生成器的微调方式与大语言模型的普通微调方法大体相同。本文将简要介绍包括格式化和非格式化数据及其优化函数的一些代表性研究。

#### [](#通用优化过程)通用优化过程

通用优化过程涉及训练数据中的输入输出对，目的是让模型学会根据输入 x 生成输出 y。

在 Self-mem\[Cheng *et al.*, 2023b\] 的研究中，采用了一种传统训练方法。给定输入 x 后，检索出相关文档 z（文中选取最相关的一个），然后结合 (x, z)，模型便生成输出 y。

论文探讨了两种主流微调方法，分别是联合编码器 (Joint-Encoder) \[Arora *et al.*, 2023, Wang *et al.*, 2022b, Lewis *et al.*, 2020\] 和双编码器 (Dual-Encoder) \[Xia *et al.*, 2019, Cai *et al.*, 2021, Cheng *et al.*, 2022\]。

在联合编码器模式下，使用的是标准的编解码器模型，编码器首先处理输入，然后解码器通过注意力机制将编码结果结合起来，自回归地生成 Token。

H\=Encoder(x\[SEP\]m)H=Encoder(x\[SEP\]m)H\=Encoder(x\[SEP\]m)

hi\=Decoder(CrossAttn(H),y<i)h^i=Decoder(CrossAttn(H),y<i)hi\=Decoder(CrossAttn(H),y<i)

PGξ(.∣x,y<i)\=Softmax(hi)P\_{G\_\\xi }(.|x,y<i)=Softmax(h^i)PGξ​​(.∣x,y<i)\=Softmax(hi)

在双编码器系统中，构建了两个独立的编码器，各自负责输入（查询、上下文）和文档的编码。接着，这些输出将依次经由解码器处理，进行双向交叉注意力处理。作者采用了 Transformer \[Vaswani 等人，2017\] 作为两种架构的基础，并对 Gξ 负对数似然（NLL）损失进行了优化。

Hx\=SourceEncoder(x)Hm\=MemoryEncoder(x)H\_x=SourceEncoder(x) H\_m=MemoryEncoder(x)Hx​\=SourceEncoder(x)Hm​\=MemoryEncoder(x)

hi\=Decoder(CrossAttn(Hx,Hm),y<i)h^i=Decoder(CrossAttn(H\_x,H\_m),y<i)hi\=Decoder(CrossAttn(Hx​,Hm​),y<i)

Lnll\=−∑t\=1∣y∣logPGξ(yt∣x,m,y<t)\\mathfrak{L}\_{nll}= - \\sum\_{t=1}^{\\left| y \\right|}logP\_{G\_\\xi }(y\_t|x,m,y<t)Lnll​\=−t\=1∑∣y∣​logPGξ​​(yt​∣x,m,y<t)

#### [](#运用对比学习)运用对比学习

在训练数据准备阶段，通常会生成输入和输出之间的交互对，以此进行对比学习。

在这种情境下，模型仅能接触到一个实际的输出，可能会导致“暴露偏差”问题 \[Ranzato 等人，2015\]：即在训练阶段，模型仅接触到单一的正确反馈，无法了解其他可能的生成 Token。

这可能影响模型在实际应用中的表现，因为它可能过度适应训练数据中的特定反馈，而不是有效泛化到其他情境。因此，SURGE \[Kang 等人，2023\] 提出了一种基于图文的对比学习方法。对于输入和输出之间的任何一对交互，这种对比学习方法的目标可以这样定义：

Lcont\=12logesim(ζ(z),ξ(h))/ι∑h′esim(ζ(z),ξ(h′))/ι+12logesim(ζ(z),ξ(h))/ι∑z′esim(ζ(z′),ξ(h))/ι\\mathfrak{L}\_{cont}={\\frac{1}{2}log\\frac{e^{sim(\\zeta (z),\\xi (h))/\\iota }}{\\sum\_{h'} e^{sim(\\zeta (z),\\xi (h'))/\\iota }}} + {\\frac{1}{2}log\\frac{e^{sim(\\zeta (z),\\xi (h))/\\iota }}{\\sum\_{z'} e^{sim(\\zeta (z'),\\xi (h))/\\iota }}}Lcont​\=21​log∑h′​esim(ζ(z),ξ(h′))/ιesim(ζ(z),ξ(h))/ι​+21​log∑z′​esim(ζ(z′),ξ(h))/ιesim(ζ(z),ξ(h))/ι​

其中 ζ\\zetaζ,ξ\\xiξ 是可学习的线性投影层。z 代表编码器中图形的平均表征，h 是解码器中的平均表征。z′z'z′,h′h'h′ 分别代表相应的负面样本。

在这段文本中，符号 'h' 和 'z' 代表负样本。模型通过采用对比学习（contrastive learning）的方法，可以更有效地学习生成各种合理的回复，而不局限于训练数据中的示例。这种方法有助于降低过拟合的风险，从而在真实世界的场景中提高模型的泛化能力。

在处理涉及结构化数据的检索任务时，SANTA\[Li *et al.*, 2023d\] 的研究采用了三个阶段的训练过程，旨在深入理解数据的结构和语义信息。

具体地，在检索器的训练阶段，使用了对比学习来优化查询和文档的嵌入表示，其优化目标如下：

LDR\=−logesim(q,d+)ef(q,d+)+∑d−∈D−esim(q,d−)\\mathfrak{L}\_{DR}=-log\\frac{e^{sim(q,d^{+})}}{e^{f(q,d^{+})}+\\sum\_{d^{-}\\in D^{-}}e^{sim(q,d^{-})}}LDR​\=−logef(q,d+)+∑d−∈D−​esim(q,d−)esim(q,d+)​

在这里，q 和 d 分别是编码器处理后的查询和文档。d−d^{-}d− 和 d+d^{+}d+ 分别代表负样本和正样本。在生成器的初期训练阶段，我们通过对比学习来对齐结构化数据和非结构化数据的相关文档描述。其优化目标与上述相同。

在生成器的后期训练阶段，我们受到参考文献 \[16, 17\] 的启发，认识到在检索任务中，实体语义对于学习文本数据表示的重要性。因此，我们首先对结构化数据进行实体识别，然后在生成器训练数据的输入部分对这些实体应用掩码，使得生成器能够预测这些被掩盖的部分。此阶段的优化目标为：

LMEP\=∑j\=1k−logP(Yd(tj)∣Xdmask,Yd(t1,...,j−1))\\mathfrak{L}\_{MEP}=\\sum\_{j=1}^{k} -logP(Y\_d(t\_j)|X\_{d}^{mask},Y\_d(t\_1,...,j-1))LMEP​\=j\=1∑k​−logP(Yd​(tj​)∣Xdmask​,Yd​(t1​,...,j−1))

在序列 YdY\_{d}Yd​ 中，Yd(yjY\_d(y\_jYd​(yj​ 表示第 j 个 Token。这里，YdY\_{d}Yd​ = <mask\>1<mask>\_1<mask\>1​，ent1ent\_1ent1​，...，<mask\>n<mask>\_n<mask\>n​，entnent\_nentn​ 表示一个包含了部分被掩盖的实体信息的序列。训练过程中，我们通过分析上下文中的信息来揭示这些被掩盖的实体，理解文本的结构性语义，并将其与结构化数据中的相关实体对应起来。我们的目标是让语言模型能够有效填补这些缺失的信息，并更深入地理解实体的含义\[21\]。

## [](#6-rag-技术的增强手段)6 RAG 技术的增强手段

本章主要从三个方面来介绍 RAG 技术的进展：增强阶段、数据源和增强过程。

![图 4：RAG 核心技术的分类。](/images/ai-series/rag/RAG_mindMap.png)

图 4：RAG 核心技术的分类。

### [](#61-rag-在各个增强阶段的应用)6.1 RAG 在各个增强阶段的应用

RAG 作为一项知识密集型任务，在语言模型训练的预训练、微调和推理阶段采用了多种技术手段。

#### [](#预训练阶段)预训练阶段

在预训练阶段，研究人员努力通过检索方法来提升预训练语言模型在开放领域问答中的表现。预训练模型中隐含知识的识别和扩充是一项挑战。2023 年，Arora *et al.* 提出了 REALM，一种更为模块化且易于理解的知识嵌入方法。REALM 采用掩蔽语言模型（MLM）的方式，将预训练和微调视为一种先检索再预测的过程，即语言模型根据掩蔽的句子 x 预测掩蔽的 Token y，建模 P(x|y)。

2022 年，Borgeaud *et al.* 提出的 RETRO 则是利用检索增强来预训练自回归语言模型，它通过从大量标记数据集中检索信息，实现了从零开始的大规模预训练，并显著减少了模型的参数量。

RETRO 不仅与 GPT 模型共享主体结构，还增加了一个 RETRO 编码器，用于编码从外部知识库检索得到的相关实体的特征。

更进一步，RETRO 在其解码器的 Transformer 结构中加入了分块交叉注意力层，有效地融合了来自 RETRO 编码器的检索信息。这使 RETRO 在处理复杂问题时，比标准的 GPT 模型表现出更低的困惑度。此外，RETRO 在更新语言模型存储的知识时更加灵活，可以通过更新检索数据库来实现，无需重新训练整个模型 \[Petroni *et al.*，2019\]。

Atla\[Izacard *et al.*, 2022\]采用了与 T5 架构\[Raffel *et al.*, 2020\]相似的方法，在预训练和微调阶段都融入了检索机制。在开始预训练之前，Atla 会先用已经预训练好的 T5 初始化其编解码器的大语言模型基础，并用预训练好的 Contriever 初始化密集检索器。

在预训练的过程中，相较于传统的预训练模型，这种方法通过减少参数的使用，提高了效率。它特别擅长处理需要大量知识的任务，并可以通过在特定领域的语料库上训练来构建专门的模型。但这种方法也有其不足之处，如需要大量预训练数据、更多的训练资源，以及更新速度较慢。特别是当模型尺寸增大时，基于检索的训练成本会相对增高。尽管存在这些限制，这种方法在增强模型的鲁棒性方面表现出色。一旦训练完成，基于纯预训练的检索增强模型就不再需要外部库的依赖，从而提高了生成速度和操作效率。

#### [](#微调阶段)微调阶段

在下游微调阶段，研究人员采用了多种方法来提高检索器和生成器在开放域问答任务中的信息检索能力。例如，REPlUG\[Shi *et al.*, 2023\] 把语言模型 (LM) 当作黑盒来处理，并通过一个可调节的检索模型进行优化。REPLUG 通过监督信号从黑盒语言模型中获取反馈，进而改善初始的检索模型。而 UPRISE\[Cheng *et al.*, 2023a\] 通过在多样化的任务集上进行微调，创建了一个轻量且灵活的检索器。

这种检索器能够为零样本任务自动生成检索提示，展现了其在不同任务和模型上的通用性和优越性能。

同时，研究人员也在微调生成器方面做出了努力。例如，Self-Mem\[Cheng *et al.*, 2023b\] 通过利用示例池对生成器进行微调，而 Self-RAG\[Asai *et al.*, 2023b\] 则通过生成反射 Token (reflection tokens) 来满足主动检索的需求。

RA-DIT\[Lin *et al.*, 2023\] 方法则是通过提高在检索增强指令下正确答案出现的概率来同时微调生成器和检索器。它通过最小化文档与查询之间的语义相似度，有效地利用了相关的背景知识。

此外，SUGRE\[Kang *et al.*, 2023\] 引入了对比学习 (contrastive learning) 的概念，实现了检索器和生成器的端到端微调，从而保证了文本生成的高度精确性和检索的子图的详细性。

SURGE 则利用基于图神经网络 (Graph Neural Networks) 的上下文感知子图检索器，从知识图谱中提取与进行中对话相关的知识，确保生成的回应忠实地反映了检索到的知识。为了达到这个目的，SURGE 使用了一个高效且不变的图编码器，以及一个图文对比学习目标。

总的来说，微调阶段的增强方法有几个显著特征。

首先，对大语言模型（LLM）和检索器进行微调可以更好地适应特定任务，这提供了同时或单独微调任一者的灵活性。例如，RePlug\[Shi *et al.*, 2023\] 和 RA-DIT\[Lin *et al.*, 2023\] 方法展示了这一点。其次，微调有助于模型适应多样化的下游任务，如 UPRISE\[Cheng *et al.*, 2023a\] 所示，使模型更加多功能。此外，微调还使模型能更好地处理不同数据结构的多种语料库，尤其是在处理图结构语料库方面有明显优势，SUGRE 方法就是一个例证。

然而，微调阶段也存在局限性，比如需要特别为 RAG 微调准备的数据集，以及与推理阶段相比需要更多的计算资源。总体来说，在微调阶段，研究人员可以根据特定需求和数据格式定制模型，在减少资源消耗的同时，仍能调整模型的输出风格。

#### [](#推理阶段)推理阶段

在推理阶段，RAG 方法与大语言模型的结合成为了研究的热点。例如，Naive RAG 就是在推理阶段融入检索内容的一个研究模式。

为了弥补 Naive RAG 的不足，研究者在推理阶段的 RAG 中引入了更多上下文。DSP\[Khattab *et al.*, 2022\] 框架通过一个复杂的流程，在冻结的语言模型（LM）和检索模型（RM）间传递自然语言文本，为模型提供更丰富的上下文，从而提升生成质量。PKG 则为大语言模型装备了一个知识引导模块，允许模型在不更改参数的情况下访问相关知识，使其能够执行更复杂的任务。同时，CREA-ICL\[Li *et al.*, 2023b\] 利用同步检索跨语言知识来获取额外信息，而 RECITE 则通过从大语言模型中抽取一个或多个段落来构建上下文。

在推理阶段，对 RAG 进程的优化有助于模型适应更复杂的任务。

例如，ITRG\[Feng *et al.*, 2023a\] 通过迭代检索和寻找正确的推理路径，提高了模型处理多步推理任务的适应能力。

ITER-RETGEN\[Shao *et al.*, 2023\] 采用了一种创新的迭代方式，将信息检索和内容生成紧密结合。这种方法轮流进行“以检索助力生成”的过程和“以生成反哺检索”的过程，从而有效地提升了信息的准确性和相关性。 而 IRCOT\[Trivedi *et al.*, 2022\] 则是一种结合了 RAG 和 CoT\[Wei *et al.*, 2022\] 理念的方法。它通过交替使用 CoT 引导的检索和利用检索结果来强化 CoT，有效地提升了 GPT-3 在各类问答任务中的表现，这突出了融合检索与生成技术的巨大潜力。

总结来说，推理阶段的增强技术因其轻量、高效、无需额外训练以及能够有效利用已有的强大预训练模型而备受推崇。其最大的特点是在模型微调时保持大语言模型（LLM）的参数不变，重点在于根据不同需求提供更加贴切的上下文信息，同时具有快速和成本低的优势。然而，这种方法也存在一些局限，比如需要额外的数据处理和流程优化，以及受限于基础模型的性能。为了更好地适应不同的任务需求，这种方法通常会与诸如逐步推理、迭代推理和自适应检索等优化技术结合使用。

### [](#62-数据增强来源)6.2 数据增强来源

数据来源对 RAG (Retrieval-Augmented Generation) 的效果至关重要。不同的数据来源提供不同粒度和维度的知识，因此需要采取不同的处理方式。主要分为三类：非结构化数据、结构化数据以及大语言模型生成的内容。

#### [](#非结构化数据增强)非结构化数据增强

在非结构化数据方面，这类数据主要是文本型的，通常源自纯文本的语料库。除此之外，还有其他文本数据可用于检索，例如用于大模型微调的 Prompt 数据\[Cheng *et al.*, 2023a\] 和跨语言数据\[Li *et al.*, 2023b\]。

在处理文本的粒度上，除了常见的句子块之外，检索的单元还可以是 Token（例如 kNN-LM\[Khandelwal *et al.*, 2019\]）、短语（如 NPM\[Lee *et al.*, 2020\]，COG\[Vaze *et al.*, 2021\]）以及文档段落。更细致的检索单元能更好地应对罕见模式和领域外的场景，但相应地，检索成本也会上升。

在词汇层面，FLARE 实行一种主动检索策略，仅在大语言模型生成低概率词时启动检索。这种方法涉及先生成一个临时的下一句话用于检索相关文档，然后根据检索到的文档再次生成下一句话，以预测接下来的句子。

在文本块的层面，RETRO 则使用前一个块来检索与之最接近的块，并将这些信息融合进前一个块的上下文中，用以指导下一个块的生成。具体来说，RETRO 通过从检索数据库中提取前一个块的最近邻块 N(Ci−1)，并将之前块的上下文信息（C1\*，...，C\*i−1）与 N(Ci−1) 的检索信息结合，通过交叉关注机制，来指导下一个块 Ci 的生成。为了保持因果逻辑的连贯性，生成第 i 个块 Ci 时，只能参考前一个块的最近邻 N(Ci−1)，而不能使用 N(Ci)。

#### [](#结构化数据增强)结构化数据增强

在结构化数据的增强方面，像知识图谱（Knowledge Graph, KG）这类数据源正逐步融入到 RAG 的框架中。经验证的知识图谱能提供更高品质的上下文信息，从而减少模型产生错觉的可能性。

例如，RET-LLM\[Modarressi *et al.*, 2023\] 构建了一个个性化的知识图谱记忆，它通过从过往对话中提取关系三元组，用于未来的对话处理。

SUGRE\[Kang *et al.*, 2023\] 使用图神经网络 (GNN) 嵌入从知识图谱中检索到的相关子图，这样做可以避免模型生成与话题无关的回复。

SUGRE\[Kang *et al.*, 2023\] 采用一种图编码方法，该方法将图结构融入到预训练模型 (PTMs) 的表征空间，并利用图文模式之间的多模态对比学习目标来确保检索到的事实与生成文本的一致性。

KnowledgeGPT\[Wang *et al.*, 2023c\] 生成的代码格式搜索查询适用于知识库 (KB)，并包括预定义的 KB 操作函数。除了检索功能，KnowledgeGPT 还能够在个性化知识库中存储知识，以满足用户的个性化需求。这些结构化数据源为 RAG 提供了更加丰富的知识和上下文，从而提升模型性能。

#### [](#llm-生成的内容-rag)LLM 生成的内容 RAG

鉴于 RAG 回忆的辅助信息有时效果不佳，甚至可能适得其反，部分研究对 RAG 的应用范式进行了拓展，深入探讨了大语言模型 (LLM) 的内部知识。这种方法通过利用 LLM 自身生成的内容来进行检索，目的是提高下游任务的性能。以下是该领域一些重要的研究： SKR\[Wang *et al.*, 2023d\] 使用了一个标记好的训练集，将模型能够直接回答的问题归类为“已知”，而需要额外检索增强的问题归类为“未知”。该模型训练用于区分问题是否为“已知”，仅对“未知”的问题应用检索增强，而对其他问题直接给出答案。

GenRead\[Yu *et al.*, 2022\] 将检索器替换为 LLM 生成器。实验结果显示，由 LLM 生成的上下文文档中包含正确答案的情况比传统 RAG 检索的更常见，并且生成的答案质量更高。作者认为，这是因为生成文档级上下文的任务与因果性语言建模的预训练目标相匹配，使得模型能更有效地利用存储在参数中的世界知识。

Selfmem\[Cheng *et al.*, 2023b\] 通过迭代使用检索增强的生成器，建立了一个无限的记忆池。系统中包含一个记忆选择器，用于选择一个生成输出作为后续生成过程的记忆。这个输出对应于原始问题的另一面。通过结合原始问题和其对立面，检索增强的生成模型能够利用自身的输出来自我提升。

这些不同的方法展示了 RAG 检索增强领域的创新策略，目的是提高模型的性能和有效性。

### [](#63-增强过程)6.3 增强过程

在大部分 RAG（检索与生成）研究中，通常仅执行单次检索和生成操作。然而，单次检索可能携带重复信息，导致生成内容“失焦”\[Liu *et al.*, 2023\]。这类重复信息可能掩盖关键信息或包含与正确答案相悖的内容，从而负面影响生成质量\[Yoran *et al.*, 2023\]。此外，单次检索所获取的信息在需要多步骤推理的问题上表现有限。

目前优化检索过程的主要方法包括迭代检索和自适应检索。这些方法使模型能够在检索过程中进行多次迭代或根据不同的任务和场景自适应地调整检索方式。

#### [](#迭代检索)迭代检索

通过定期收集基于原始查询和生成文本的文档，可以为大语言模型 (LLM) 提供更多参考资料\[Borgeaud *et al.*, 2022, Arora *et al.*, 2023\]。多次迭代检索中增加的参考资料已经提升了后续答案生成的稳健性。然而，这种方法可能在语义上存在断裂，有时还可能收集到杂乱无用的信息，因为它主要依靠一连串 Token 来区分生成和检索的文档。

递归检索和多跳检索应用于特定的数据场景。递归检索首先通过结构化索引处理数据，再逐层进行检索。在检索层次丰富的文档时，可以为每个部分制作摘要，无论是整篇文档还是长篇 PDF。在基于摘要进行检索后，一旦确定了文档，就对其内部的各个部分进行二次检索，实现递归检索。多跳检索则常用于深入挖掘图结构数据源中的信息\[Li *et al.*, 2023c\]。

一些方法结合了检索和生成步骤的迭代。

ITER-RETGEN \[Shao *et al.*, 2023\] 结合了“检索增强生成”和“生成增强检索”，适用于需要复现信息的任务。即模型利用完成任务所需的内容来回应输入的任务，这些内容随后成为检索更多相关知识的信息背景。这有助于在下一次迭代中生成更优的回应。

IRCoT\[Trivedi *et al.*, 2022\] 探索了在思维链的每个步骤中检索文档的方法，为每生成一句话就进行一次检索。它利用 CoT（连续任务）来指导检索，并用检索结果来优化 CoT，从而确保语义的完整性。

#### [](#适应性检索)适应性检索

在适应性检索的领域，Flare\[Jiang *et al.*, 2023b\] 和 Self-RAG\[Asai *et al.*, 2023b\] 等方法对常规的 RAG 方法进行了改进。传统的 RAG 方法在检索信息时采取被动方式，而这些新方法则让大语言模型 (LLM) 能主动决定何时以及检索什么内容，从而提高信息检索的效率和准确性。

事实上，大语言模型 (LLM) 主动利用工具并进行判断的做法，并非始于 RAG，而是已在许多大型模型的 AI 智能体中得到广泛应用\[Yang *et al.*, 2023c, Schick *et al.*, 2023, Zhang, 2023\]。

以 Graph-Toolformer\[Zhang, 2023\] 为例，它的检索步骤分为几个阶段：LLM 主动利用检索器，通过少样本提示激发搜索查询。当 LLM 认为有必要时，会主动搜索相关问题，以收集必需信息，类似于 AI 智能体调用工具的过程。

WebGPT\[Nakano *et al.*, 2021\] 则利用强化学习训练 GPT-3 模型，使其通过特殊 Token 在搜索引擎上进行查询、浏览和引用，从而在文本生成中有效利用搜索引擎。

Flare\[Jiang *et al.*, 2023b\] 则通过自动判断信息检索的最佳时机，有效减少了文档检索的成本。该方法通过监测文本生成过程中的概率变化，一旦生成术语的概率降到一定阈值以下，就会触发信息检索系统，补充所需的知识。

Self-RAG\[Asai *et al.*, 2023b\] 则引入了一种新颖的“反思 Token”，分为“检索”和“批评”两种。这使得模型能够根据设定的标准自主决定检索信息的时机，从而有效地获取所需段落。

在需要进行信息检索时，生成器会同时处理多个段落，并采用一种称为“片段级 beam search”的技术来确定最优的内容组合。这个过程中，各个部分的重要性通过一种叫做“评审分数 (Critic scores)”的方法来评估并更新，而且这些分数在生成答案的过程中可以根据需要调整，以此来定制模型的响应方式。Self-RAG 框架的一个创新之处在于，它允许大语言模型 (LLM) 自己决定是否需要回顾过去的信息，这样就避免了额外训练分类器或依赖于自然语言推理 (NLI) 模型。这大大提升了模型自主判断信息并生成准确回答的能力。

## [](#7-rag-评估)7 RAG 评估

在探索和优化 RAG（检索增强生成器）的过程中，如何有效评估其性能已经成为关键问题。本章节主要围绕评估方法、RAG 应具备的关键指标、它的核心能力，以及一些常用的评估框架进行讨论。

### [](#71-评估方法)7.1 评估方法

主要有两种方法来评估 RAG 的有效性：独立评估和端到端评估\[Liu, 2023\]。

#### [](#独立评估)独立评估

独立评估涉及对检索模块和生成模块（即阅读和合成信息）的评估。

1.  **检索模块**：评估 RAG 检索模块的性能通常使用一系列指标，这些指标用于衡量系统（如搜索引擎、推荐系统或信息检索系统）在根据查询或任务排名项目的有效性。这些指标包括命中率 (Hit Rate)、平均排名倒数 (MRR)、归一化折扣累积增益 (NDCG)、精确度 (Precision) 等。
    
2.  **生成模块**：生成模块指的是将检索到的文档与查询相结合，形成增强或合成的输入。这与最终答案或响应的生成不同，后者通常采用端到端的评估方式。生成模块的评估主要关注上下文相关性，即检索到的文档与查询问题的关联度。
    

#### [](#端到端评估)端到端评估

端到端评估是对 RAG 模型对特定输入生成的最终响应进行评估，涉及模型生成的答案与输入查询的相关性和一致性。

从内容生成的目标来看，评估可分为无标签和有标签的内容评估。无标签内容的评估指标包括答案的准确性、相关性和无害性，而有标签内容的评估指标则包括准确率 (Accuracy) 和精确匹配 (EM)。此外，根据评估方法的不同，端到端评估可分为人工评估和使用大语言模型 (LLM) 的自动评估。总的来说，这些是 RAG 端到端评估的常规方法。特定领域的 RAG 应用还会采用特定的评估指标，如问答任务的精确匹配 (EM)\[Borgeaud *et al.*, 2022, Izacard *et al.*, 2022\]，摘要任务的 UniEval 和 E-F1\[Jiang *et al.*, 2023b\]，以及机器翻译的 BLEU\[Zhong *et al.*, 2022\]。

这些指标有助于理解 RAG 在各种特定应用场景中的表现。

### [](#72-关键指标和能力)7.2 关键指标和能力

现有研究往往缺乏对检索增强的大语言模型 (LLM) 生成效果的严格评估。通常情况下，评估 RAG 在不同下游任务和不同检索器中的应用可能会得到不同的结果。然而，一些学术和工程实践已经开始关注 RAG 的通用评估指标和有效运用所需的能力。本节主要介绍评估 RAG 有效性的关键指标和评估其性能所需的基本能力。

#### [](#关键指标)关键指标

最近的 OpenAI 报告 \[Jarvis and Allard, 2023\] 讨论了优化大语言模型（大语言模型）的多种技术，其中包括 RAG 及其评估标准。

此外，像 RAGAS \[Es *et al.*, 2023\] 和 ARES \[Saad-Falcon *et al.*, 2023\] 这样的最新评估框架也应用了 RAG 的评估标准。梳理这些研究，主要集中于三个关键指标：答案的准确性、答案的相关性和上下文的相关性。

1.  答案准确性：这个指标着重保证模型生成的答案与给定上下文的真实性一致，确保答案不会与上下文信息发生冲突或偏离。这一评价标准对于避免大型模型中的误导至关重要。
    
2.  答案相关性：此指标强调生成的答案需要紧密联系问题本身。
    
3.  上下文相关性：此指标要求提取的上下文信息必须尽可能精确和具有针对性，以避免无关内容。毕竟，长文本的处理对大语言模型来说成本很高，过多无关信息会降低模型利用上下文的效率。OpenAI 的报告还特别提及了“上下文提取”作为一项补充指标，用于衡量模型回答问题所需的相关信息检索能力。这个指标反映了 RAG 检索模块的搜索优化程度。低回忆率可能暗示需要优化搜索功能，例如引入重新排序机制或调整嵌入，以确保检索到更相关的内容。
    

#### [](#关键能力)关键能力

RGB \[Chen *et al.*, 2023b\] 的研究分析了不同大语言模型在处理 RAG 所需的四项基本能力方面的表现，包括抗噪声能力、拒绝无效回答能力、信息综合能力和反事实稳健性，从而为检索增强型生成设立了标准。RGB 关注以下四个能力：

1.  **抗噪声能力：** 这项能力评估模型处理与问题相关但无效信息的噪声文档的效率。
    
2.  **拒绝无效回答能力：** 当模型检索到的文档缺乏解决问题所需的信息时，模型应正确地拒绝回答。在测试拒绝无效回答时，外部文档仅包含无效信息。理想状态下，大语言模型应发出“信息不足”或类似的拒绝信号。
    
3.  **信息综合能力：** 这项能力评价模型是否能整合多个文档中的信息，以回答更复杂的问题。
    
4.  **反事实鲁棒性测试：** 此项测试旨在评估模型在被告知检索信息可能存在风险时，是否能识别并纠正文档中的错误信息。反事实鲁棒性测试包括一些大语言模型能直接回答的问题，但相关外部文档却含有错误事实。
    

### [](#73-评估框架)7.3 评估框架

近来，大语言模型社群开始探索将大语言模型用作评估者的自动评估方法，许多研究使用如 GPT-4 这样的先进模型来评估他们的大语言模型应用效果。Databricks 就曾使用 GPT-3.5 和 GPT-4 作为评估者，来审视他们的聊天机器人应用，结果显示这种自动评估方式颇为有效\[Leng *et al.*, 2023\]。他们还认为，这种方法对于基于检索 - 生成 (RAG) 应用的评估既高效又节约成本。在 RAG 评估框架领域，RAGAS 和 ARES 是较新的方法。这些评估主要关注三个核心指标：答案的准确性、相关性和上下文相关性。此外，业界提出的开源库 TruLens 也采用了类似的评估方式。所有这些框架都将大语言模型作为评估者。由于 TruLens 与 RAGAS 相似，本节将重点介绍 RAGAS 和 ARES。

#### [](#ragas)RAGAS

这个框架关注于检索系统挑选关键上下文段落的能力、大语言模型准确利用这些段落的能力以及生成内容的整体质量。RAGAS 是一个基于简单手写提示的评估框架，通过这些提示全自动地衡量答案的准确性、相关性和上下文相关性。在此框架的实施和试验中，所有提示都通过 OpenAI API 中的 gpt-3.5-turbo-16k 模型进行评估\[Es *et al.*, 2023\]。

##### [](#算法原理)算法原理

1.  **答案忠实度评估**：利用大语言模型 (LLM) 分解答案为多个陈述，检验每个陈述与上下文的一致性。最终，根据支持的陈述数量与总陈述数量的比例，计算出一个“忠实度得分”。
2.  **答案相关性评估**：使用大语言模型 (LLM) 创造可能的问题，并分析这些问题与原始问题的相似度。答案相关性得分是通过计算所有生成问题与原始问题相似度的平均值来得出的。
3.  **上下文相关性评估**：运用大语言模型 (LLM) 筛选出直接与问题相关的句子，以这些句子占上下文总句子数量的比例来确定上下文相关性得分。

#### [](#ares)ARES

ARES 的目标是自动化评价 RAG 系统在上下文相关性、答案忠实度和答案相关性三个方面的性能。这些评价指标与 RAGAS 中的相似。但是，RAGAS 作为一个基于简单手写提示的较新评估框架，在适应新 RAG 评估场景方面有一定局限性，这正是 ARES 项目的显著意义。此外，ARES 在评估中的表现明显不如 RAGAS。ARES 减少了评估成本，通过使用少量的手动标注数据和合成数据，并应用预测驱动推理 (PDR) 提供统计置信区间，提高了评估的准确性\[Saad-Falcon 等人，2023\]。

##### [](#算法原理-1)算法原理

1.  **生成合成数据集**：ARES 首先使用语言模型从目标语料库中的文档生成合成问题和答案，创建正负两种样本。
2.  **训练大语言模型 (LLM) 裁判**：然后，ARES 对轻量级语言模型进行微调，利用合成数据集训练它们以评估上下文相关性、答案忠实度和答案相关性。
3.  **基于置信区间对 RAG 系统排名**：最后，ARES 使用这些裁判模型为 RAG 系统打分，并结合手动标注的验证集，采用 PPI 方法生成置信区间，从而可靠地评估 RAG 系统的性能。

## [](#8-未来展望)8 未来展望

在本章中，我们讨论了 RAG 的三大未来发展方向：垂直优化、横向扩展以及 RAG 生态系统的构建。

### [](#81-rag-的垂直优化)8.1 Rag 的垂直优化

尽管 RAG 技术在过去一年里取得了显著进展，但其垂直领域仍有几个重点问题有待深入探究。

首先是 RAG 中长上下文的处理问题。正如文献 \[Xu *et al.*, 2023c\] 所指出的，RAG 在生成内容时受限于大语言模型（LLM）的上下文窗口大小。窗口过小可能导致相关信息不足，而窗口过大又可能引发信息丢失。目前，不断扩大 LLM 上下文窗口的尺度，甚至实现无限上下文，已成为大语言模型研发的关键方向。然而，一旦上下文窗口的限制被移除，RAG 如何适应这一变化，成为了值得关注的问题。

其次，RAG 的鲁棒性研究也是一个重要焦点。在检索过程中，如果出现无关噪声或与事实矛盾的内容，会显著影响 RAG 的效果。这种情况就像“打开一本书偶遇毒蘑菇”，因此，如何增强 RAG 的鲁棒性，已成为研究者们关注的热点，相关研究有 \[Yu *et al.*, 2023a, Glass *et al.*, 2021, Baek *et al.*, 2023\] 等。

第三，RAG 与微调（Fine-tuning）的协同作用也是研究的重点之一。例如 RA-DIT \[Lin *et al.*, 2023\] 等研究表明，混合方法已成为 RAG 的主流趋势。如何在保持参数化和非参数化优势的同时，有效协调这两者之间的关系，是一个待解决的问题。

最后，RAG 的工程应用也备受关注。RAG 之所以兴起，部分原因在于其实施简易且符合企业工程需求。

然而，在工程实践中，诸如如何在大规模知识库场景中提高检索效率和文档召回率，以及如何保障企业数据安全——例如防止 LLM 被诱导泄露文档的来源、元数据或其他敏感信息——都是亟待解决的关键问题 \[Alon *et al.*, 2022\]。

#### [](#rag-的水平扩展)RAG 的水平扩展

在水平领域，RAG 的研究也在迅速扩展。从最初的文本问答领域出发，RAG 的应用逐渐拓展到更多模态数据，包括图像、代码、结构化知识、音视频等。在这些领域，已经涌现出许多相关研究成果。

在图像领域，BLIP-2\[Li *et al.*, 2023a\] 的提案采用了冻结的图像编码器和大语言模型（Large Language Model）来进行视觉语言的预训练，这大大降低了模型训练的成本。更为重要的是，该模型能够基于零样本（Zero-shot）实现从图像到文本的转换。

在文本生成领域，VBR\[Zhu *et al.*, 2022\] 方法通过生成图像来引导语言模型进行文本创作，这在开放式文本生成任务中显示出显著的效果。

在编码领域，RBPS\[Nashid *et al.*, 2023\] 被应用于与编码相关的小规模学习过程。该方法通过编码或频率分析，能够自动寻找与开发者当前任务相似的代码示例，这在测试断言的生成和程序修复方面已被证明是非常有效的。

在结构化知识领域，如 CoK\[Li *et al.*, 2023c\] 所示的方法，首先从知识图谱中提取与提问内容相关的事实，然后以提示的形式将这些事实融入到输入中。这种方法在知识图谱问答任务中表现出色。

对于音频和视频领域，GSS\[Zhao *et al.*, 2022\] 方法通过从口语词库中检索和串联音频剪辑，能够迅速将机器翻译（MT）数据转换为语音翻译（ST）数据。UEOP\[Chan *et al.*, 2023\] 在端到端自动语音识别中带来了新的突破，引入了用于将声音转换为文本的外部离线策略。

利用文本到语音方法产生的音频嵌入和语义文本嵌入，可以通过基于 KNN 的注意力融合策略优化自动语音识别（ASR），有效地缩短了领域适应的时间。

Vid2Seq\[Yang *et al.*, 2023a\] 架构通过引入特殊的时间标记，增强了语言模型，使其能够在同一输出序列中无缝地预测事件边界和文本描述。

### [](#82-rag-生态系统)8.2 RAG 生态系统

#### [](#下游任务和评估)下游任务和评估

通过整合来自广泛知识库的相关信息，RAG 展示了在处理复杂查询和生成信息丰富回应方面的巨大潜力。众多研究表明，RAG 在开放式问题回答、事实验证等多种下游任务中表现优异。RAG 模型不仅提升了下游应用中信息的准确性和相关性，还增加了回应的多样性和深度。

RAG 的成功为其在多领域应用的适用性和普适性的探索铺平了道路，未来的工作将围绕此进行。特别是在医学、法律和教育等专业领域的知识问答中，RAG 的应用可能会相比微调 (fine-tuning) 提供更低的训练成本和更优的性能表现。

同时，完善 RAG 的评估体系，以更好地评估和优化它在不同下游任务中的应用，对提高模型在特定任务中的效率和效益至关重要。这涉及为各种下游任务开发更精准的评估指标和框架，如上下文相关性、内容创新性和无害性等。

此外，增强 RAG 模型的可解释性，让用户更清楚地理解模型如何以及为何作出特定反应，也是一项重要任务。

#### [](#技术栈)技术栈

在 RAG 的技术生态系统中，相关技术栈的发展起着推动作用。例如，随着 ChatGPT 的流行，LangChain 和 LLamaIndex 迅速成为知名技术，它们提供丰富的 RAG 相关 API，成为大模型时代的关键技术之一。与此同时，新型技术栈也在不断涌现。尽管这些新技术并不像 LangChain 和 LLamaIndex 那样功能众多，但它们更注重自身的独特特性。例如，Flowise AI6 着重于低代码操作，使用户能够通过简单的拖拽实现 RAG 代表的各类 AI 应用。其他新兴技术如 HayStack、Meltno 和 Cohere Coral 也在不断发展。

除了 AI 原生框架，传统软件或云服务供应商也在拓展服务范围。比如，向量数据库公司 Weaviate 推出的 Verba7 专注于个人助理领域，而亚马逊则通过其智能企业搜索服务 Kendra，基于 RAG 思想为用户提供服务，使他们可以在不同的内容仓库中进行搜索。

技术栈的发展与 RAG 的进步相互促进。新技术对现有技术栈提出了更高的要求，而技术栈功能的优化又进一步推动了 RAG 技术的发展。综合来看，RAG 工具链的技术栈已经初步建立，许多企业级应用逐步出现。然而，一个全面的一体化平台仍在完善中。

## [](#9-结论)9 结论

本篇论文深入探讨了检索增强型生成（Retrieval-Augmented Generation, RAG）技术。这种技术利用外部知识库来丰富大语言模型（LLMs）的上下文并生成答案。RAG 的特点在于，它结合了大语言模型中的参数化知识和外部的非参数化知识，有效减少生成信息的误差和虚假内容，利用检索技术获取及时信息，从而提升了答案的准确度。此外，RAG 通过引用资料来源，提高了模型输出的透明度和用户对结果的信任度。RAG 还可以根据特定的领域需要，通过整合相关的文本数据来进行定制。

RAG 的发展可以归纳为三种模式：基础型 RAG、高级型 RAG 和模块化 RAG。这三种模式各自拥有不同的模型、方法及其局限性。基础型 RAG 主要进行简单的“检索 - 阅读”操作。高级型 RAG 则在数据处理上更为精细，优化了知识库索引，并采用了多次或迭代式的检索方法。

随着技术的深入探索，RAG 开始融入微调等其他技术，形成了模块化 RAG。这一新模式通过引入新模块，使得 RAG 过程更加丰富和灵活。

在论文的后续部分，我们将深入分析 RAG 的三个核心组成部分。第四部分介绍了 RAG 的检索机制，包括如何处理文本数据以获得更准确的语义表示，缩小查询与文档间的语义差距，以及如何调整检索器以更好地配合生成器。第五部分阐述了生成器如何通过后处理检索到的文档来提升生成质量，避免信息处理过程中的缺失，并探讨了如何调整生成器以更好地适应检索器。第六部分回顾了目前提升检索效果的各种方法，从检索阶段、数据来源和检索过程等方面进行了探讨。

第七部分讲述了如何评估现有的 RAG 方法，包括评估标准、关键指标和目前的评估框架。最后，我们对 RAG 的未来研究方向进行了展望。作为结合了检索和生成的技术，RAG 在未来的研究中拥有广阔的发展空间。随着技术的不断完善和应用范围的扩大，RAG 的性能和实用性将得到进一步的提升。















[NingG]:    http://ningg.github.io  "NingG"
[premAI]:		https://book.premai.io/state-of-open-source-ai/








