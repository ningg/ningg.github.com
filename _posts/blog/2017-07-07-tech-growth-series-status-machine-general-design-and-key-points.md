---
layout: post
title: 技术成长系列：状态机的通用设计和实现
description: 为什么需要状态机？如何快速、准确的设计一个状态机？
published: true
category: 技术成长系列
---

## 概要

> 1. blog 的讨论焦点：分析、设计状态机的极简思路和要点，不涵盖 BPM，也不涵盖 Activiti 类似的框架；
> 2. blog 的结果预期：一般场景下，能够快速、准确设计一个合适的状态机，平滑支撑业务\架构演进；

几个朴素的问题：

1. 状态机，是什么？
1. 有什么价值？
1. 具体业务场景中，如何设计一个合适的状态机？
1. 怎么实现一个状态机？

实际上，作为架构师，面对一个具体场景，需要进行一系列的准备工作（前期的分析、设计）。

这些分析和设计工作，有几个重要产出：

1. 业务子系统拆分（拆分预期）
1. 服务化拆分边界（拆分预期）
1. 领域模型
1. 状态机

至于其他的分库分表、中间件引入等是业务发展到一定阶段的具体技术点，不是针对一个完整场景的架构设计，有缘分今后会细讲。

> 做一点分享，通过反复分析人月神话以及敏捷开发实践，时间的分配上，我的心理有个基本标准：设计、开发、测试，`3`+`3`+`3` 

## 目标

关于状态机的设计和实现：

1. 基本规则
1. 可行步骤
1. 最佳实践
1. 讨论

面向对象：

1. 技术团队
1. 产品团队
1. 业务、技术感兴趣的同学

### 状态机

基本原则：

1. 状态互斥
1. 严格流转

关键点：

1. 状态：
	1. 暂态
	1. 终态
1. 触发方式：
	1. 时间触发
	1. 事件触发

状态机设计的可行步骤：

1. 分析：业务场景抽象，收集状态变更的条件筛选
1. 设计：状态流转
1. 实现

Note：

* 软件设计原则：SRP

## 实例

### 场景

实验平台的场景：

> 实验平台中，实验的状态流转。

目标：

1. 怎么设计一个状态机，平滑的支持业务？
1. 怎么实现？实现细节上，有没有问题？

### 分析

1. **对象**实体：实验
1. 实体的状态**变更条件**：
	1. 创建
	1. 生效：开始时间，实验自动生效
	1. 暂停：人为操作
	1. 恢复：人为操作
	1. 结束：结束实践，实验自动结束
	1. 上线：人为操作
	1. 删除：人为操作
1. 实体，**不同状态**下的**权限**：
	1. 是否可编辑
	1. 是否可删除
	1. etc.

### 设计

设计过程

* 状态：暂态、终态

![](images/tech-growth/status-machine-experiment-part1.png)

![](images/tech-growth/status-machine-experiment-part2.png)

### 实现

软件设计原则：

* SRP

状态流转

* 触发方式：
	* 时间触发：`定时任务`扫描
	* 事件触发：`事件入口`，按图索骥，做好控制

使用上面方式，一般几百行 java 代码，就能实现一个通用的状态流转，很简单清晰。

实现的部分细节：

* 状态是否实时变更

## 总结


基本原则：

1. 状态互斥
1. 严格流转

关键点：

1. 状态：暂态、终态
1. 触发方式：时间触发、事件触发

状态机设计的可行步骤：

1. 分析：业务场景抽象，收集对象实体状态变更的条件筛选
	1. 对象
	1. 状态以及变更条件
	1. 不同状态下的操作权限
1. 设计：状态流转
1. 实现：软件设计原则，SRP










[NingG]:    http://ningg.github.com  "NingG"










